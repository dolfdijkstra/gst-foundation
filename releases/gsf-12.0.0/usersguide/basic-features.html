<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.1 at 2016-10-17 
 | Rendered using Apache Maven Fluido Skin 1.5
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20161017" />
    <meta http-equiv="Content-Language" content="en" />
    <title>GST Site Foundation for WebCenter Sites &#x2013; </title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.5.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />

      
    <script type="text/javascript" src="../js/apache-maven-fluido-1.5.min.js"></script>

                      </head>
        <body class="topBarDisabled">
          
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>GST Site Foundation for WebCenter Sites</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
              
                  <li id="publishDate">Last Published: 2016-10-17
                      <span class="divider">|</span>
                   </li>
                  <li id="projectVersion">Version: 12.0.0
                      </li>
                      
              
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
              
                <ul class="nav nav-list">
                    <li class="nav-header">Overview</li>
                              
      <li>
  
                          <a href="../index.html" title="Introduction">
          <span class="none"></span>
        Introduction</a>
            </li>
                
      <li>
  
                          <a href="../download.html" title="Download">
          <span class="none"></span>
        Download</a>
            </li>
                
      <li>
  
                          <a href="../quickstart.html" title="Quick Start Guide">
          <span class="none"></span>
        Quick Start Guide</a>
            </li>
                                                                                                                                                                
      <li>
  
                          <a href="../usersguide/overview.html" title="User's Guide">
          <span class="icon-chevron-down"></span>
        User's Guide</a>
                    <ul class="nav nav-list">
                    
      <li>
  
                          <a href="../usersguide/typical-usage.html" title="Typical usage">
          <span class="none"></span>
        Typical usage</a>
            </li>
                    
      <li>
  
                          <a href="../usersguide/upgrade.html" title="Upgrading">
          <span class="none"></span>
        Upgrading</a>
            </li>
                    
      <li class="active">
  
            <a href="#"><span class="none"></span>Basic features</a>
          </li>
                    
      <li>
  
                          <a href="../usersguide/advanced-features.html" title="Advanced features">
          <span class="none"></span>
        Advanced features</a>
            </li>
                    
      <li>
  
                          <a href="../usersguide/facades.html" title="Facades highlights">
          <span class="none"></span>
        Facades highlights</a>
            </li>
                    
      <li>
  
                          <a href="../usersguide/variables.html" title="Built-in variables">
          <span class="none"></span>
        Built-in variables</a>
            </li>
              </ul>
        </li>
                
      <li>
  
                          <a href="../install.html" title="Install Guide">
          <span class="none"></span>
        Install Guide</a>
            </li>
                
      <li>
  
                          <a href="../gsf-core/apidocs/index.html" title="Javadoc">
          <span class="none"></span>
        Javadoc</a>
            </li>
                
      <li>
  
                          <a href="../ReleaseNotes.html" title="Release Notes">
          <span class="none"></span>
        Release Notes</a>
            </li>
                
      <li>
  
                          <a href="../docs.html" title="Documentation Home">
          <span class="none"></span>
        Documentation Home</a>
            </li>
                
      <li>
  
                          <a href="../news-archive.html" title="News Archive">
          <span class="none"></span>
        News Archive</a>
            </li>
                
      <li>
  
                          <a href="../license.html" title="License">
          <span class="none"></span>
        License</a>
            </li>
                              <li class="nav-header">Development</li>
                              
      <li>
  
                          <a href="../dev/building.html" title="Building">
          <span class="none"></span>
        Building</a>
            </li>
                
      <li>
  
                          <a href="../issue-tracking.html" title="Issue Tracking">
          <span class="none"></span>
        Issue Tracking</a>
            </li>
                
      <li>
  
                          <a href="../source-repository.html" title="Source Repository">
          <span class="none"></span>
        Source Repository</a>
            </li>
                              <li class="nav-header">Modules</li>
                              
      <li>
  
                          <a href="../gsf-core/index.html" title="GSF Core">
          <span class="none"></span>
        GSF Core</a>
            </li>
                
      <li>
  
                          <a href="../gsf-legacy/index.html" title="GSF Legacy">
          <span class="none"></span>
        GSF Legacy</a>
            </li>
                              <li class="nav-header">Previous Versions</li>
                              
      <li>
  
                          <a href="../../gsf-11.6.2/site/index.html" title="11.6.2">
          <span class="none"></span>
        11.6.2</a>
            </li>
                
      <li>
  
                          <a href="../../gsf-11.6.1/site/index.html" title="11.6.1">
          <span class="none"></span>
        11.6.1</a>
            </li>
                
      <li>
  
                          <a href="../../gsf-11.6.0/site/index.html" title="11.6.0">
          <span class="none"></span>
        11.6.0</a>
            </li>
                
      <li>
  
                          <a href="../../gsf-1.3.1/gst-foundation-kit-1.3.1.tar" title="1.3.1">
          <span class="none"></span>
        1.3.1</a>
            </li>
                
      <li>
  
                          <a href="../../gsf-1.3/gst-foundation-kit-1.3.tar" title="1.3">
          <span class="none"></span>
        1.3</a>
            </li>
            </ul>
              
                            <form id="search-form" action="https://www.google.com/search" method="get" >
    
  <input value="$sitesearchValue" name="sitesearch" type="hidden"/>
  <input class="search-query" name="q" id="query" type="text" />
</form>
<script type="text/javascript" src="https://cse.google.com/brand?form=search-form"></script>
          
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                   
        
        
        
    <iframe src="https://www.facebook.com/plugins/like.php?href=http://dolfdijkstra.github.com/gst-foundation&send=false&layout=box_count&show-faces=false&action=like&colorscheme=light"
        scrolling="no" frameborder="0"
        style="border:none; width:48px; height:63px; margin-top: 10px;" ></iframe>
               <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span10" >
                                  
            <div class="section">
<h2><a name="GSF_Users_Guide"></a>GSF User's Guide</h2>
<div class="section">
<h3><a name="How_to_-_basic_features"></a>How to - basic features</h3>
<p><a href="#Using_the_GSF_in_your_project">Using the GSF in your project</a></p>
<p><a href="#Use_the_OOTB_Factory_Producer_and_Factory_Implementations">Use the OOTB Factory Producer and Factory Implementations</a></p>
<p><a href="#Use_Your_Own_Factory_Implementation">Use Your Own Factory Implementation</a></p>
<p><a href="#Use_the_ServiceProducer_Annotation_tools.gsf.config.ServiceProducer">Use the @ServiceProducer Annotation (tools.gsf.config.ServiceProducer)</a></p>
<p><a href="#Use_the_InjectForRequest_Annotation_tools.gsf.config.inject.InjectForRequest">Use the @InjectForRequest Annotation (tools.gsf.config.inject.InjectForRequest)</a></p>
<p><a href="#Use_the_Bind_Annotation_tools.gsf.config.inject.Bind">Use the @Bind Annotation (tools.gsf.config.inject.Bind)</a></p>
<p><a href="#Use_the_CurrentAsset_Annotation_tools.gsf.facade.assetapi.asset.CurrentAsset">Use the @CurrentAsset Annotation (tools.gsf.facade.assetapi.asset.CurrentAsset)</a></p>
<p><a href="#Use_the_Mapping_Annotation_tools.gsf.mapping.Mapping">Use the @Mapping Annotation (tools.gsf.mapping.Mapping)</a></p>
<p><a href="#Use_Your_Own_Asset_Type_as_a_GST_Property_Asset">Use Your Own Asset Type as a GST Property Asset</a></p>
<p><a href="#Make_Your_Own_Beans__Objects_Available_for_Injection">Make Your Own Beans / Objects Available for Injection</a></p>
<p><a href="#Inject_Your_Own_Beans__Objects_Into_a_WCS_12c_Controller">Inject Your Own Beans / Objects Into a WCS 12c Controller</a></p></div></div>
<div class="section">
<h2><a name="Using_the_GSF_in_your_project"></a>Using the GSF in your project</h2>
<p>Adding the GSF to your project does not require any special setup or configuration. To begin leveraging the features of <b>gsf-core</b>, simply add <b>gsf-core-VERSION.jar</b> to your project's Java classpath.</p></div>
<div class="section">
<h2><a name="Use_the_OOTB_Factory_Producer_and_Factory_Implementations"></a>Use the OOTB Factory Producer and Factory Implementations</h2>
<ul>
<li>GSF object factories are very powerful and allow you to leverage inversion of control by configuring your application in a central location. GSF 12 introduces the concept of <b>scoped factories</b>:</li>
<li>GSF requires 2 scoped factories at all times, one for each scope driving WCS (and the GSF itself):
<ul>
<li>ICS scope and</li>
<li>ServletContext scope.</li></ul></li>
<li>Base factory implementations are provided for each scope, out-of-the-box:
<ul>
<li>ICS scope: <b>tools.gsf.config.IcsBackedFactory</b></li>
<li>ServletContext scope: <b>tools.gsf.config.ServletContextBackedFactory</b></li></ul></li>
<li>Factory Producer is responsible for instantiating all scoped factories supporting the system. A base factory producer implementation is provided, out-of-the-box: DefaultFactoryProducer.</li>
<li>A <b>fallback mechanism</b> enables the GSF automatically looking up an object in the ServletContext-scoped factory whenever it is not found in the ICS-scoped factory. <b>DefaultFactoryProducer</b> is responsible for wiring up such fallback mechanism, e.g. by making ServletContextBackedFactory the <b>&quot;delegate&quot; factory</b> of IcsBackedFactory.</li>
<li>No settings / tweaks are required in order to use the built-in Factory Producer (DefaultFactoryProducer). GSF will default to it unless you configure a custom Factory Producer.</li>
<li>No settings / tweaks are required in order to use the built-in scoped Factories, provided that:
<ul>
<li>You are using the DefaultFactoryProducer, and</li>
<li>You are not using any custom built factories instead of the OOTB ones.</li></ul></li>
<li>You can easily retrieve your ICS-scoped factory instance in one line:
<div class="source"><pre class="prettyprint linenums">Factory myIcsScopedFactory = FactoryLocator.locateFactory(ics);  // ics is your ICS instance</pre></div></li>
<li>If, for whatever reason, you needed to get ahold of the ServletContext-scoped factory (remember that magical fallback mechanism), you can easily do so:
<div class="source"><pre class="prettyprint linenums">FactoryProducer fp = FactoryProducer.locateFactoryProducer(servletContext); // servletContext is your ServletContext instance
Factory myServletContextScopedFactory = fp.getFactory(servletContext);</pre></div></li>
<li>In theory, you can even define your own &quot;scopes&quot;, as long as you comply with the due interfaces / contract.
<ul>
<li>GSF does not know how to delegate from any custom scopes onto the built-in ones (nor viceversa). It's your responsibility defining your own Factory implementation's lookup logic as well as the due delegation strategy -- perhaps, supported by a custom Factory Producer implementation, too.</li></ul></li></ul></div>
<div class="section">
<h2><a name="Use_Your_Own_Factory_Implementation"></a>Use Your Own Factory Implementation</h2>
<ul>
<li>Implement your own custom factory.
<ul>
<li>Typically, you'll want to extend either <b>tools.gsf.config.IcsBackedFactory</b> or <b>tools.gsf.config.ServletContextBackedFactory</b> .</li>
<li>The only true requisite is that you implement the <b>tools.gsf.config.Factory</b> interface.</li>
<li>There are other factories you could either extend or reuse (for instance, SpringObjectFactory)</li></ul></li>
<li>Register it:
<ol style="list-style-type: decimal">
<li>Create a file named &quot;gsf-factory&quot;.</li>
<li>Inside your &quot;gsf-factory&quot; file, specify the fully-qualified name of your custom factory class(es).
<ul>
<li>For overriding the default ICS-scoped factory, add a line like this:
<div class="source"><pre class="prettyprint linenums">COM.FutureTense.Interfaces.ICS:foo.wee.whatever.MyCustomIcsBackedFactory</pre></div></li>
<li>For overriding the default ServletContext-scoped factory, add a line like this:
<div class="source"><pre class="prettyprint linenums">javax.servlet.ServletContext:foo.wee.whatever.MyCustomServletContextBackedFactory</pre></div></li></ul></li>
<li>Package that file inside the &quot;META-INF&quot; folder of any JAR you are deploying inside the WCS 12c web app.
<ul>
<li>Typically, you'd put it inside your custom JAR file (e.g. the one containing the custom factory producer class itself).</li></ul></li>
<li>Deploy the JAR file containing your &quot;gsf-factory&quot; file inside the WCS web app.</li></ol></li>
<li>BEAR IN MIND:
<ul>
<li>GSF requires (at least) 2 factories, one for each supported <b>scope</b>:
<ul>
<li>COM.FutureTense.Interfaces.ICS (a.k.a. &quot;ICS&quot; scope) and</li>
<li>javax.servlet.ServletContext (a.k.a. &quot;ServletContext&quot; scope).</li></ul></li>
<li>GSF's <b>built-in fallback mechanism</b> enables its looking up an object in the ServletContext-scoped factory whenever it is not found in the ICS-scoped factory.</li>
<li>If you don't explicitly configure a factory for these 2 scopes via &quot;gsf-factory&quot; file, they will default to:
<div class="source"><pre class="prettyprint linenums">COM.FutureTense.Interfaces.ICS:tools.gsf.config.IcsBackedFactory
javax.servlet.ServletContext:tools.gsf.config.ServletContextBackedFactory</pre></div></li></ul></li></ul></div>
<div class="section">
<h2><a name="Use_the_ServiceProducer_Annotation_tools.gsf.config.ServiceProducer"></a>Use the @ServiceProducer Annotation (tools.gsf.config.ServiceProducer)</h2>
<ul>
<li>This annotation supports the <b>AbstractDelegatingFactory</b> base class for factory implementations.</li>
<li>This annotation will identify a method as a Service Producer. A service producer is a method that creates an object that is returned by the factory class.</li>
<li>Service Producer methods are meaningful only to subclasses of <b>AbstractDelegatingFactory</b></li>
<li>This annotation provides the following settings:
<ul>
<li><b>cache</b> (OPTIONAL): indicates if the object should be cached or not. It defaults to <b>false</b>.</li>
<li><b>name</b> (OPTIONAL): the &quot;name&quot; of the Service. It's an &quot;alias&quot; for the method's prototype, used by factories when looking up an object. It defaults to an empty string.</li></ul></li>
<li>Lookup logic and limitations:
<ul>
<li>The <b>Factory.getObject(String name, Class&lt;T&gt; type)</b> method ultimately provide the ability to look up or retrieve an object from the factory. The mechanism by which this lookup occurs is up to the implementation to decide.</li>
<li><b>AbstractDelegatingFactory</b>'s subclasses, like <b>IcsBackedFactory</b> and <b>ServletContextBackedFactory</b> utilize the following lookup mechanism:.</li>
<li>Fallback from &quot;named&quot; ServiceProducer methods onto &quot;unnamed&quot; ServiceProducer methods is provided OOTB, meaning:
<ul>
<li>Factory.getObject(objectName, type) looks across all &quot;named&quot; Service Producers (i.e. methods where @ServiceProducer.name != null):
<ul>
<li>If a method is found, then that's the method producing the object to be returned, lookup finishes.</li>
<li>Otherwise, Factory.getObject(objectName, type) looks across all &quot;unnamed&quot; Service Producers (i.e. methods where @ServiceProducer.name == null):
<ul>
<li>If the object is found, that's the object that gets injected.</li>
<li>Otherwise, Factory.getObject(objectName, type) returns:
<ul>
<li>If there is a delegate factory: delegateFactory.getObject().
<ul>
<li>OOTB, IcsBackedFactory delegates into ServletContextBackedFactory.</li></ul></li>
<li>If there is not a delegate factory: null.</li></ul></li></ul></li></ul></li></ul></li>
<li>Whenever you specify a ServiceProducer.name for a given method in your factory class, make sure it is unique -- including all inherited methods.</li>
<li>Although specifying ServiceProducer.name is optional, you are advised to specify it for every Service Producer or, at the very least, for all Service Producers whose return type is the same; this will avoid ambiguity and, potentially, unexpected results from your factory's &quot;getObject&quot; method.
<ul>
<li>This is especially relevant when your own factory inherits other Service Producers with the same return type from an existing factory it extends.</li>
<li>Unless you really know what you are doing, avoid overriding inherited Service Producers.</li></ul></li></ul></li>
<li>Example:
<div class="source"><pre class="prettyprint linenums">(...)

@ServiceProducer
public Stopwatch newStopwatch() {
    return LoggerStopwatch.getInstance();
}

(...)</pre></div>
<p>(NOTE: you can find multiple examples inside the IcsBackedFactory and ServletContextBackedFactory classes)</p></li></ul></div>
<div class="section">
<h2><a name="Use_the_InjectForRequest_Annotation_tools.gsf.config.inject.InjectForRequest"></a>Use the @InjectForRequest Annotation (tools.gsf.config.inject.InjectForRequest)</h2>
<ul>
<li>This annotation will look up the specified object (bean / service) in the configured <b>ics-scoped</b> Factory and it will inject it into the annotated field / method.</li>
<li>It provides the following settings:
<ul>
<li><b>value</b> (OPTIONAL): the &quot;name&quot; of the object (bean / service) to be looked up. If not specified, &quot;value&quot; will default to:
<ul>
<li>Case annotated field: the name of the annotated field.</li>
<li>Case annotated method: output of org.springframework.beans.BeanUtils.findPropertyForMethod(method).getName().</li></ul></li></ul></li>
<li>Example:
<div class="source"><pre class="prettyprint linenums">(...)

/**
 * Provide a DAO that allows an asset to be easily mapped
 */
@InjectForRequest
protected TemplateAssetAccess templateAssetAccess;

(...)</pre></div></li></ul></div>
<div class="section">
<h2><a name="Use_the_Bind_Annotation_tools.gsf.config.inject.Bind"></a>Use the @Bind Annotation (tools.gsf.config.inject.Bind)</h2>
<ul>
<li>This annotation will look for the specified variable in the specified scope (&quot;ics&quot;, &quot;request&quot; or &quot;session&quot;) and, if found, it will inject the value into the annotated field.</li>
<li>It provides the following settings:
<ul>
<li><b>value</b> (OPTIONAL): the name of the variable we want to look up. It defaults to the name of the annotated field.</li>
<li><b>scope</b> (OPTIONAL): the scope in which we want to look up. Supported values are &quot;ics&quot;, &quot;request&quot; and &quot;session&quot;. It defaults to &quot;ics&quot;.</li></ul></li>
<li>Lookup logic and limitations:
<ul>
<li>When the <b>extracted object is a String</b>:
<ul>
<li>If the annotated field's type is String, then it will assign the object as-is.</li>
<li>If the annotated field's type <b>is primitive (byte, int, double, float, long, short or boolean)</b>, then conversion is attempted.</li>
<li>If the annotated field's type <b>is String, Date, Integer, Double, Character or Long</b>, then conversion is attempted.</li>
<li>If the annotate field's type is none of the above, it will try to assign the object to the annotated field as-is (no conversion). If the object is not assignable, an exception will be thrown.</li></ul></li>
<li>When the <b>extracted object is NOT a String</b>:
<ul>
<li>If the annotated field's type <b>is primitive (byte, int, double, float, long, short or boolean)</b>, then conversion is attempted.</li>
<li>If the annotated field's type is of any other type, no value gets injected, annotation has no effect, no exception is thrown.</li></ul></li></ul></li>
<li>Example:
<div class="source"><pre class="prettyprint linenums">(...)

/**
 * Bind rendermode to local variable
 */
@Bind(value=&quot;rendermode&quot;)
protected String myRenderMode;

(...)</pre></div></li></ul></div>
<div class="section">
<h2><a name="Use_the_CurrentAsset_Annotation_tools.gsf.facade.assetapi.asset.CurrentAsset"></a>Use the @CurrentAsset Annotation (tools.gsf.facade.assetapi.asset.CurrentAsset)</h2>
<ul>
<li>This brand new annotation determines the current asset for the current ICS object (e.g. via c + cid), loads the asset along with the value of the attributes specified by the annotation and injects the appropriate object into the annotated field.</li>
<li>It provides the following settings:
<ul>
<li><b>attributes</b> (OPTIONAL): the &quot;name&quot; of the attributes whose values we want to pre-load for the current asset. If not specified, &quot;value&quot; will default to &quot;name&quot; (meaning the std field on every asset type / subtype named &quot;name&quot;)</li></ul></li>
<li>Lookup logic and limitations:
<ul>
<li>Current asset is determined as per the following call: AssetIdUtils.currentId(ics).</li>
<li>Supports TemplateAsset, ScatteredAsset and AssetData typed fields. Asset containers provided by other DAOs may be configured by overriding the <b>CurrentAssetInjector</b> class.</li></ul></li>
<li>IMPORTANT: be aware of the language-specific convention for specifying String arrays (Groovy = [], Java = <a name="a"></a>)</li>
<li>Examples (Groovy):
<ul>
<li>TemplateAsset:
<div class="source"><pre class="prettyprint linenums">
class MyController extends InjectingController {

        (...)

        @CurrentAsset(attributes=[&quot;title&quot;, &quot;body&quot;, &quot;headline&quot;]) TemplateAsset currentTemplateAsset;

        protected void handleRequest() {
                String headline = currentAsset.asString(&quot;headline&quot;);

                (...)
        }

        (...)

}
</pre></div></li>
<li>ScatteredAsset:
<div class="source"><pre class="prettyprint linenums">
class AnotherController extends InjectingController {

        (...)

        @CurrentAsset(attributes=[&quot;title&quot;, &quot;body&quot;, &quot;headline&quot;]) ScatteredAsset currentScatteredAsset;

        protected void handleRequest() {
                models.add(&quot;asset&quot;, currentScatteredAsset);

                (...)
        }

        (...)

}
</pre></div></li>
<li>AssetData:
<div class="source"><pre class="prettyprint linenums">
class ThirdController extends InjectingController {

        (...)

        @CurrentAsset(attributes=[&quot;title&quot;, &quot;body&quot;, &quot;headline&quot;]) AssetData currentAssetData;

        protected void handleRequest() {
                AttributeData ad = currentAssetData.getAttribute(&quot;title&quot;);

                (...)

        }

        (...)

}
</pre></div></li></ul></li></ul></div>
<div class="section">
<h2><a name="Use_the_Mapping_Annotation_tools.gsf.mapping.Mapping"></a>Use the @Mapping Annotation (tools.gsf.mapping.Mapping)</h2>
<ul>
<li>This annotation will look up a map entry matching the specified key in the Template / CSElement being executed (for the current site) and, if found, it will inject the mapped value into the annotated field.</li>
<li>It provides the following settings:
<ul>
<li><b>match</b> (OPTIONAL): the &quot;side&quot; of the mapped value you want to (retrieve and) inject. Supported values are &quot;all&quot; (equivalent to &quot;x&quot;), &quot;right&quot; (equivalent to &quot;:x&quot;) and &quot;left&quot; (equivalent to &quot;x:&quot;). It defaults to &quot;all&quot;.</li>
<li><b>value</b> (OPTIONAL): the key of the map entry whose value we want to retrieve. It defaults to the name of the annotated field.</li></ul></li>
<li>Lookup logic and limitations:
<ul>
<li>If the eid (/ tid) of the CSElement (/ Template) being executed cannot be determined, then the annotation has no effect, no exception is thrown.</li>
<li>Only fields of the following types can use this annotation (conversion is done automatically at runtime):
<ul>
<li>tools.gsf.mapping.MappingValue (applicable to all map entry types: <i>asset type: asset id</i>, template name, ...)</li>
<li>com.fatwire.assetapi.data.AssetId (applicable only to <i>asset type: asset id</i> map entries)</li>
<li>tools.gsf.mapping.AssetName (applicable only to <i>asset type: asset name</i> map entries)</li>
<li>String (applicable to all map entry types)</li></ul></li>
<li>The &quot;match&quot; setting is only relevant when the annotated field's type is String.</li>
<li>If a map entry matching the specified key and site is found, but it doesn't have a valid (and assignable) value, then an Exception is thrown.</li>
<li>Controllers can only be bound to SiteEntry and Template assets, not CSElements. However, map entries can only be specified for Template and CSElements. Hence:
<ul>
<li>You can use this annotation for mapping Template-specific map entries onto a Controller's field if you call the Template using style=&quot;embedded&quot; or style=&quot;pagelet&quot;.
<ul>
<li>When a Template is called with style=&quot;element&quot;, no Controller gets invoked.</li></ul></li>
<li>You can use this annotation for mapping CSElement-specific map entries onto a Controller's field if you invoke the CSElement via the SiteEntry the Controller is bound to.
<ul>
<li>If you call the CSElement directly, no Controller gets invoked.</li></ul></li></ul></li>
<li>This annotation only works if the &quot;pagename&quot; of the Template / SiteEntry being executed is accessible (at runtime) from within the Controller (i.e. via the ICS &quot;pagename&quot; variable).
<ul>
<li>This is due exclusively to a bug in WCS 12c's rendering logic which prevents eid / tid from being accessible at runtime from within Controllers bound to a SiteEntry(+CSELement) / Template asset.</li></ul></li></ul></li>
<li>Example:
<div class="source"><pre class="prettyprint linenums">(...)

/**
 * Bind map entry's value to local variable
 */
@Mapping(value=&quot;myMappedAsset&quot;)
protected String mappedAsset;

(...)</pre></div></li></ul></div>
<div class="section">
<h2><a name="Use_Your_Own_Asset_Type_as_a_GST_Property_Asset"></a>Use Your Own Asset Type as a GST Property Asset</h2>
<ul>
<li>Implement your own object factory and add to it a <b>Service Producer method</b> (i.e. annotated with @ServiceProducer) which instantiates the new <b>com.fatwire.gst.foundation.properties.AssetApiPropertyDao</b>.</li>
<li>Example:
<div class="source"><pre class="prettyprint linenums">
@ServiceProducer(cache = true)
public PropertyDao instantiateCustomPropertyDao(final ICS ics) {
        Session session = SessionFactory.getSession(ics);
        AssetDataManager adm = (AssetDataManager) session.getManager(AssetDataManager.class.getName());
        SiteManager sm = (SiteManager) session.getManager(SiteManager.class.getName());
        String type = &quot;MyCustomAssetType&quot;;
        String flexDefName = &quot;MyCustomFlexDefName&quot;;
        String propNameAttr = &quot;nameOfAttributeToGetThePropertyNameFrom&quot;; \\ Typically &quot;name&quot;
        String propDescAttr = &quot;nameOfAttributeToGetThePropertyDescriptionFrom&quot;; \\ Typically &quot;description&quot;
        String propValueAttr = &quot;nameOfAttributeToGetThePropertyValueFrom&quot;; \\ Typically &quot;value&quot;
        return new AssetApiPropertyDao(adm, sm, type, flexDefName, propNameAttr, propDescAttr, propValueAttr, ics);
}
</pre></div></li></ul></div>
<div class="section">
<h2><a name="Make_Your_Own_Beans__Objects_Available_for_Injection"></a>Make Your Own Beans / Objects Available for Injection</h2>
<p>See &quot;Use a Custom Asset Type as a GST Property Asset&quot; and &quot;Implement (and Use) Your Own NavService Implementation&quot; above.</p>
<p>In general, all you need to do is implement your own object factory and make your custom bean available by adding the due Service Producer (annotated) method to it.</p></div>
<div class="section">
<h2><a name="Inject_Your_Own_Beans__Objects_Into_a_WCS_12c_Controller"></a>Inject Your Own Beans / Objects Into a WCS 12c Controller</h2>
<ul>
<li>Instead of extending WCS 12c's <b>BaseController</b> class, have your controller extend the GSF's <b>tools.gsf.controller.InjectingController</b> instead. It is simple and lightweight but provides injection support to your standard <b>doWork(Map models)</b> method..
<p>If you are curious (or suspicious) as to how this works, look at the source code for GSF's <b>InjectingController.java</b>. It's trivially short.</p></li>
<li><b>A VERY IMPORTANT NOTE (WARNING) ON style=&quot;element&quot; IN WCS 12c</b>.
<p>WCS 12c will not invoke your Template's controller if you invoke your template using a render:calltemplate tag call with style=&quot;element&quot;.</p>
<p>In such scenario, if your Template's code depended on its own Controller's logic (which is usually the case), it would break.</p>
<p>Previous versions of the GSF defaulted to style=&quot;element&quot; when Type 1 actions called the childpagename template (in an attempt to intelligently set the call's style whenever you didn't set it explicitly).</p>
<p>This did not occur in WCS 11.x and previous versions since Controllers were just introduced in WCS 12c.</p>
<p>If you are using the <b>GST/Dispatcher wrapper</b>, <b>GSF actions</b> or any other LEGACY (hence deprecated) feature related to those two, be aware that combining those with the use of WCS 12c Controllers may yield erratic behaviour for the same reason.</p>
<p>You can work around this by:</p>
<ol style="list-style-type: decimal">
<li>Making sure all Layout Templates ever invoked via the GST/Dispatcher (e.g. GSF actions) are set to &quot;cached&quot;, hence preventing GSF's LEGACY CallTemplate Facade from automatically setting style=&quot;element&quot; for you, OR</li>
<li>Avoiding the use of Layout Template which rely on Controllers attached to them in conjunction with GSF Actions and/or GST/Dispatcher.</li></ol>
<p>In addition to this, if you really need to use GSF Actions AND Controllers, here are some ideas to minimize chance of your CallTemplate calls breaking (DISCLAIMER: as per the above explanation, these may not cover you 100%):</p>
<ol style="list-style-type: upper-alpha">
<li>Adjust all of your calls to <b>gsf-legacy</b>'s CallTemplate facade so to set &quot;style&quot; explicitly to something other than &quot;element&quot; whenever the called Template has a Controller attached to it.</li>
<li>Use <b>gsf-core</b>'s (new) CallTemplate facade (instead of LEGACY's), which forces your explicitly setting &quot;style&quot; on each call, and make sure you set style to the appropriate value, as per the aforementioned considerations.</li></ol>
<p>From the above, you've probably figured out already that GSF deals with the potential chaos this style-related behaviour could cause on pre-existing code you attempt migrating to WCS 12c's Controller-based paradigm simply by getting rid of the &quot;legacy&quot; intelligence.</p>
<p>This implies there are now 2 CallTemplate facades:</p>
<ul>
<li>The new one, which ships with the CORE artifact / JAR. In this one, style will NEVER be autocalculated for you. Either you set it explicitly - to the appropriate value - on each call or an Exception will be thrown.</li>
<li>The old one, which ships with the LEGACY artifact / JAR. This one has been left untouched, which means the style auto-selection intelligence is still there, with all that implies.</li></ul></li></ul></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                                      <p >Copyright &copy;                   2010&#x2013;2016.
          All rights reserved.    
      </p>
                </div>

        
                </div>
    </footer>
        </body>
</html>
